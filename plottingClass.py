__author__ = "Carlos Ardila-Gutierrez"
__maintainer__ = "Carlos Ardila-Gutierrez"
__email__ = "carlos2248383@correo.uis.edu.co"
__date__ = "January 06, 2025"

import matplotlib.pyplot as plt
import os
import numpy as np


class plottingTools:
    '''
    Class to plot physics graph.
    ==========
    Parameters
    ==========
        - property:
        - 
        -

    ======
    Return
    ======
        None.
    ======
    Tested compatibility
    ======
        - matplotlib 3.10.0
        - numpy 2.2.1
        - pyqt5
    '''
    def __init__(self):
        pass

    def _read_bands_vaspkit(self, path_read, fermi=False, kticks_bool=False):
        # IMPORTANT: To be implemented. Change reading method to np.loadtxt and test time
        '''
        Reads the bands structure generated by vaspkit1.3.5. It
        works for both spin and spinless calculations.

        ==========
        Parameters
        ==========
            - property:
            - 
            -

        ======
        Return
        ======
            None.
        '''
        # ------ single band structure file for both spin ------
        path_band = path_read + '/REFORMATTED_BAND.dat'
        if os.path.isfile(path_band):
            n = 0
            with open(path_band) as dataFile:
                for data in dataFile:
                        if n==0:
                            n+=1
                            continue
                        elif n==1:
                            n+=1
                            kpoints = []
                            E = [[] for _ in range(len(data.split())-1)]

                        kpoints.append(eval(data.split()[0]))
                        for i in range(len(data.split())-1):
                            e = eval(data.split()[i+1])
                            E[i].append(np.array(e))
        # ------- band structure files splitted by spin --------
        else:
            path_band_dw = path_read + '/REFORMATTED_BAND_DW.dat'
            path_band_up = path_read + '/REFORMATTED_BAND_UP.dat'
            n = 0
            with open(path_band_dw) as data_file:
                for data in data_file:
                        if n==0:
                            n+=1
                            continue
                        elif n==1:
                            n+=1
                            kpoints = []
                            E = [[] for _ in range(len(data.split())-1)]

                        kpoints.append(eval(data.split()[0]))
                        for i in range(len(data.split())-1):
                            e = eval(data.split()[i+1])
                            E[i].append(np.array(e))
            n = 0
            with open(path_band_up) as data_file:
                for data in data_file:
                        if n==0:
                            n+=1
                            continue
                        elif n==1:
                            n+=1

                        kpoints.append(eval(data.split()[0]))
                        for i in range(len(data.split())-1):
                            e = eval(data.split()[i+1])
                            E[i].append(np.array(e))
        # ------- Adjust fermi level from FERMI_ENERGY file ----
        if fermi:
            path_Efermi = path_read + '/FERMI_ENERGY'
            with open(path_Efermi) as data_file:
                lines = data_file.readlines()[1]
                Efermi = eval(lines.split()[0])
            for i in range(len(E)):
                e = np.array(E[i]) - Efermi
        else:
            # IMPORTANT: Only used to turn bands into np.array. Delete when method changed
            for i in range(len(E)):
                E[i] = np.array(E[i])

        # ------- kticks --------
        if kticks_bool:
            klabel, kticks = [], []
            with open(path_read + '/KLABELS') as data_file:
                for data in data_file:
                    if len(data.split())==2:
                        label = data.split()[0]
                        tick = eval(data.split()[1])
                        tick = eval(data.split()[1])
                        klabel.append(label)
                        kticks.append(tick)
        # ------- return data --------
        if kticks_bool:
            return kpoints, E, klabel, kticks
        else:
            return kpoints, E

    def plot_bands_vaspkit(self,
                           path_read,
                           E_limit=[-1, 1],
                           E_zero=0,
                           E_vaspkit=False,
                           klabels=None,
                           label=None,
                           color='k',
                           ax=None,
                           show=False):
        # =
        if klabels is None:
            kpoints, E, klabels, kticks = self._read_bands_vaspkit(path_read, fermi=E_vaspkit, kticks_bool=True)
            
        else:
            kpoints, E = self._read_bands_vaspkit(path_read, fermi=E_vaspkit, kticks_bool=False)
            klabels, kticks = klabels
        
        if ax==None:
            fig, ax = plt.subplots()
        else:
            # IMPORTANTE: CREO QUE ES MEJOR GRAFICAR COMO SI FUERAN DISTINTOS EJES
            # referenceTicks = ax.get_xticks()
            # kpoints, kTicks = fixKpath(referenceTicks, kpoints, kTicks)
            pass

        n = 0
        for band in E:
            band = band-E_zero
            if n==0 and label is not None:
                n+=1
                ax.plot(kpoints, band, c=color, linewidth=1.3, label=label)
            else:
                ax.plot(kpoints, band, c=color, linewidth=1.3)

        for ktick in kticks:
            ax.axvline(ktick, color='gray', linewidth=0.2)

        ax.set_xticks(kticks)
        ax.set_xticklabels(klabels)
        ax.set_xlim([kticks[0], kticks[-1]])
        ax.set_ylim(E_limit)
        ax.set_ylabel(r'$E-E_{F} [eV]$')
        ax.axhline(0, color='gray', linewidth=0.2)

        if show:
            plt.show()
        
        return ax, fig

class styler:
    '''
    Class to control style details of the graph.    
    '''
    def __init__(self):
        pass