__author__ = "Carlos Ardila Gutierrez"
__maintainer__ = "Carlos Ardila Gutierrez"
__email__ = "carlos2248383@correo.uis.edu.co"
__date__ = "January 06, 2025"

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import os
import numpy as np


class plottingTools:
    '''
    Class to plot physics graph.
    ==========
    Parameters
    ==========
        - property:
        - 
        -

    ======
    Return
    ======
        None.
    ======
    Tested compatibility
    ======
        - matplotlib 3.10.0
        - numpy 2.2.1
        - pyqt5
    '''
    def __init__(self):
        pass

    def _read_bands_vaspkit(self, path_read, fermi=False, kticks_bool=False):
        '''
        Reads the band structure generated by vaspkit1.3.5. It
        works for both spin and spinless calculations.

        ==========
        Parameters
        ==========
            - property:
            - 
            -

        ======
        Return
        ======
            None.
        '''
        # ------ single band structure file for both spin ------
        path_band = path_read + '/REFORMATTED_BAND.dat'
        if os.path.isfile(path_band):
            data = np.loadtxt(path_band, skiprows=1)
            data = data.transpose()
            kpoints = data[0]
            E = data[1:]
        # ------- band structure files splitted by spin --------
        else:
            path_band_dw = path_read + '/REFORMATTED_BAND_DW.dat'
            path_band_up = path_read + '/REFORMATTED_BAND_UP.dat'
            data = np.loadtxt(path_band_dw, skiprows=1)
            data = data.transpose()
            kpoints = data[0]
            E = data[1:]
            data = np.loadtxt(path_band_up, skiprows=1)
            data = data.transpose()
            E = np.append(E, data[1:], axis=0)
        # ------- Adjust fermi level from FERMI_ENERGY file ----
        if fermi:
            path_Efermi = path_read + '/FERMI_ENERGY'
            Efermi = np.loadtxt(path_Efermi, skiprows=1)
            for i in range(len(E)):
                E[i] += Efermi
        # ------- kticks --------
        if kticks_bool:
            klabel, kticks = [], []
            with open(path_read + '/KLABELS') as data_file:
                for data in data_file:
                    if len(data.split())==2:
                        label = data.split()[0]
                        tick = eval(data.split()[1])
                        klabel.append(label)
                        kticks.append(tick)
            kticks = np.array(kticks)
        # ------- return data --------
        if kticks_bool:
            return kpoints, E, klabel, kticks
        else:
            return kpoints, E

    def plot_bands_vaspkit(self,
                           path_read,
                           E_limit=[-1, 1],
                           E_zero=0,
                           E_vaspkit=False,
                           klabels=None,
                           label=None,
                           color='k',
                           ax=None,
                           show=False,
                           savefile=None):
        '''
        Plot the band structure generated by vaspkit1.3.5. It
        works for both spin and spinless calculations.

        ==========
        Parameters
        ==========
            path_read
                - Path to the folder where the band structure files are located.
            E_limit=[-1 1]
                - Energy limits of the graph.
            E_zero=0
                - Energy reference.
            E_vaspkit=False
                - If True, the fermi level is adjusted by the value on FERMI_ENERGY file, plus the value on 'E_zero'.
            klabels=None
                - Labels of the high symmetry k-points.
            label=None
                - Label of the band. If None, it is read the labels on the KLABELS file.
            color='k'
                - Color of the band.
            ax=None
                - Axes object to plot the band.
            show=False
                - If True, the graph is shown.
            savefile=None
                - If not None, the graph is saved with the name entered in the variable 'savefile'.

        ======
        Return
        ======
            ax, fig.
        '''
        # -------------- reads info --------------
        if klabels is None:
            kpoints, E, klabels, kticks = self._read_bands_vaspkit(path_read, fermi=E_vaspkit, kticks_bool=True)
        else:
            kpoints, E = self._read_bands_vaspkit(path_read, fermi=E_vaspkit, kticks_bool=False)
            klabels, kticks = klabels
        # ------------ ax, fig objects -----------
        if ax==None:
            fig, ax = plt.subplots()
        else:
            # IMPORTANTE: CREO QUE ES MEJOR GRAFICAR COMO SI FUERAN DISTINTOS EJES
            # referenceTicks = ax.get_xticks()
            # kpoints, kTicks = fixKpath(referenceTicks, kpoints, kTicks)
            pass
        # ------ plot klabels and set limits ------
        for ktick in kticks:
            ax.axvline(ktick, color='gray', linewidth=0.2)
        ax.set_xticks(kticks)
        ax.set_xticklabels(klabels)

        ax.set_xlim([kticks[0], kticks[-1]])
        ax.set_ylim(E_limit)
        ax.set_ylabel(r'$E-E_{F} [eV]$')
        ax.axhline(0, color='gray', linewidth=0.2)
        # -------------- plot bands --------------
        n = 0
        for band in E:
            band = band-E_zero
            if n==0 and label is not None:
                n+=1
                ax.plot(kpoints, band, c=color, linewidth=1.3, label=label)
            else:
                ax.plot(kpoints, band, c=color, linewidth=1.3)
        
        if show:
            plt.show()
        if savefile is not None:
            plt.savefig(savefile)

        return fig, ax

class styler:
    '''
    Class to control style details of the graph.    
    '''
    def __init__(self, fig, ax):
        self.fig = fig
        self.ax = ax
        self.ax.format_coord = lambda x, y: 'x={:g}, y={:g}'.format(x, y) # To show coords.

    def set_style(self, style='default'):
        '''
        Set the style of the graph. It uses the matplotlib styles.
        '''
        plt.style.use(style)

    def set_size(self, figSize=[10, 8], figdpi=300):
        '''
        Set the dimensions of the graph.
        '''
        figWidht, figHeight = figSize
        self.fig.set_size_inches(figWidht, figHeight)
        self.fig.set_dpi(figdpi)
        self.fig.subplots_adjust()

    def set_title(self, maintitle=None, ax_title=None,
                    mtitle_fontsize=20, ax_title_fontsize=12):
        '''
        Set the titles of the graph.
        '''
        if maintitle:
            self.fig.suptitle(maintitle, fontsize=mtitle_fontsize)
        if ax_title:
            self.ax.set_title(ax_title, fontsize=ax_title_fontsize)

    def set_scale(self, scale_x='linear', scale_y='linear'):
        '''
        Set the scale used on each of the axes.
        '''
        self.ax.set_yscale(scale_x)
        self.ax.set_yscale(scale_y)

    def set_labels(self, xlabel=None, ylabel=None,
                    fontsize_xlabel=None, fontsize_ylabel=None):
        '''
        manage the labels of the graph.
        '''
        # ------------ Set the labels of the graph. ------------
        if xlabel:
            self.ax.set_xlabel(xlabel)
        if ylabel:
            self.ax.set_ylabel(ylabel)
        # ------------ Set the size of the text. ------------
        if fontsize_xlabel:
            self.ax.xaxis.label.set_fontsize(fontsize_xlabel)
        if fontsize_ylabel:
            self.ax.yaxis.label.set_fontsize(fontsize_ylabel)

    def set_ticks(self, xticks_step=None, yticks_step=None,
                  fontsize_xticks=None, fontsize_yticks=None):
        # ------------ Control step of the ticks. ------------
        if xticks_step:
            self.ax.xaxis.set_major_locator(ticker.MultipleLocator(xticks_step))
        if yticks_step:
            self.ax.yaxis.set_major_locator(ticker.MultipleLocator(yticks_step))
        # ------------ set fontsize of the ticks. ------------
        if fontsize_xticks:
            self.ax.tick_params(axis='x', labelsize=fontsize_xticks)
        if fontsize_yticks:
            self.ax.tick_params(axis='y', labelsize=fontsize_yticks)

    def set_lim(self, xlim=None, ylim=None):
        '''
        Set the limits of the graph.
        '''
        if xlim:
            self.ax.set_xlim(xlim)
        if ylim:
            self.ax.set_ylim(ylim)

    def set_frame_thickness(self, thickness=1):
        '''
        change te thickness of the frame of the graph.
        '''
        self.ax.spines['top'].set_linewidth(thickness)
        self.ax.spines['bottom'].set_linewidth(thickness)
        self.ax.spines['left'].set_linewidth(thickness)
        self.ax.spines['right'].set_linewidth(thickness)

    def return_fig_ax(self):
        return self.fig, self.ax

    def savefig(self, savefile, dpi=300, format='png'):
        '''
        Save the figure.
        '''
        self.fig.savefig(savefile+f'.{format}', dpi=dpi, format=format)


    def bandstructure_style(self, savefile=None):
        '''
        A default configuration for band structures figures.
        '''
        self.set_labels(ylabel=r'$E-E_{F} [eV]$', fontsize_ylabel=18)
        # self.set_scale()

        # self.ax.axhline(0, color='gray', linewidth=0.2)
        
        ylim = self.ax.get_ylim()
        self.set_ticks(yticks_step=min(abs(np.array(ylim)))/3, fontsize_yticks=14,
                        fontsize_xticks=14)

        self.set_size(figSize=[12, 8], figdpi=300)

        if savefile:
            self.savefig(savefile)


'''
def legend_thickness(self, thickness=1):
    plt.rc('legend',fontsize=20) # using a size in points
    plt.rc('legend',fontsize='medium')
''' 