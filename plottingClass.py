__author__ = "Carlos Ardila Gutierrez"
__maintainer__ = "Carlos Ardila Gutierrez"
__email__ = "carlos2248383@correo.uis.edu.co"
__date__ = "January 06, 2025"

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import os
import numpy as np


class plottingTools:
    '''
    Class to plot physics graph.
    ==========
    Parameters
    ==========
        - property:
        - 
        -

    ======
    Return
    ======
        None.
    ======
    Tested compatibility
    ======
        - matplotlib 3.10.0
        - numpy 2.2.1
        - pyqt5
    '''
    def __init__(self):
        pass

    def _read_bands_vaspkit(self, path_read, fermi_vaspkit=False, klabels_bool=False, kticks_bool=False):
        '''
        Reads the band structure generated by vaspkit1.3.5. It
        works for both spin and spinless calculations.

        ==========
        Parameters
        ==========
            - property:
            - 
            -

        ======
        Return
        ======
            None.
        '''
        # ------ single band structure file for both spin ------
        path_band = path_read + '/REFORMATTED_BAND.dat'
        if os.path.isfile(path_band):
            data = np.loadtxt(path_band, skiprows=1)
            data = data.transpose()
            kpoints = data[0]
            E = data[1:]
        # ------- band structure files splitted by spin --------
        else:
            path_band_dw = path_read + '/REFORMATTED_BAND_DW.dat'
            path_band_up = path_read + '/REFORMATTED_BAND_UP.dat'
            data = np.loadtxt(path_band_dw, skiprows=1)
            data = data.transpose()
            kpoints = data[0]
            E = data[1:]
            data = np.loadtxt(path_band_up, skiprows=1)
            data = data.transpose()
            E = np.append(E, data[1:], axis=0)
        # ------- Adjust fermi level from FERMI_ENERGY file ----
        if fermi_vaspkit:
            path_Efermi = path_read + '/FERMI_ENERGY'
            Efermi = np.loadtxt(path_Efermi, skiprows=1)
            for i in range(len(E)):
                E[i] += Efermi
        # ------- kticks & klabels --------
        if klabels_bool or kticks_bool:
            klabel, kticks = [], []
            with open(path_read + '/KLABELS') as data_file:
                for data in data_file:
                    if len(data.split())==2:
                        label = data.split()[0]
                        tick = eval(data.split()[1])
                        klabel.append(label)
                        kticks.append(tick)
            kticks = np.array(kticks)
        # ------- return data --------
        if klabels_bool and kticks_bool:
            return kpoints, E, klabel, kticks
        elif klabels_bool and not kticks_bool:
            return kpoints, E, klabel
        elif not klabels_bool and kticks_bool:
            return kpoints, E, kticks
        else:
            return kpoints, E

    def __plot_bands_vaspkit_break(self,
                            path_read,
                            E_limit=[-1, 1],
                            E_zero=0,
                            E_vaspkit=False,
                            klabels= None,
                            kticks=None,
                            kbreaks=None,
                            label=None,
                            color='k',
                            ax=None,
                            show=False,
                            savefile=None):
        pass

    def plot_bands_vaspkit(self,
                           path_read,
                           E_limit=[-1, 1],
                           E_zero=0,
                           E_vaspkit=False,
                           klabels= None,
                           kticks=None,
                           kbreaks=None,
                           label=None,
                           color='k',
                           ax=None,
                           show=False,
                           savefile=None):
        '''
        Plot the band structure generated by vaspkit1.3.5. It
        works for both spin and spinless calculations.

        ==========
        Parameters
        ==========
            path_read
                - Path to the folder where the band structure files are located.
            E_limit=[-1 1]
                - Energy limits of the graph.
            E_zero=0
                - Energy reference.
            E_vaspkit=False
                - If True, the fermi level is adjusted by the value on FERMI_ENERGY file, plus the value on 'E_zero'.
            klabels=None
                - Labels of the high symmetry k-points.
            kticks=None
                - Ticks of the high symmetry k-points.
            kbreaks=None
                - Breaks of the high symmetry k-points.
            label=None
                - Label of the band. Default is None.
            color='k'
                - Color of the band.
            ax=None
                - Axes object to plot the band.
            show=False
                - If True, the graph is shown.
            savefile=None
                - If not None, the graph is saved with the name entered in the variable 'savefile'.

        ======
        Return
        ======
            ax, fig.
        '''
        # -------------- reads info --------------
        if klabels is None and kticks is None:
            kpoints, E, klabels, kticks = self._read_bands_vaspkit(path_read, fermi=E_vaspkit, klabels_bool=True, kticks_bool=True)
        elif klabels is None and kticks is not None:
            kpoints, E, klabels = self._read_bands_vaspkit(path_read, fermi=E_vaspkit, klabels_bool=True, kticks_bool=False)
        elif klabels is not None and kticks is None:
            kpoints, E, kticks = self._read_bands_vaspkit(path_read, fermi=E_vaspkit, klabels_bool=False, kticks_bool=True)
        else:
            kpoints, E = self._read_bands_vaspkit(path_read, fermi=E_vaspkit, klabels_bool=False, kticks_bool=False)
        # ------------ ax, fig objects -----------
        if ax is None and kbreaks is None:
            fig, ax = plt.subplots()
        elif ax is None and kbreaks is not None:
            num_ax = len(kbreaks)+1
            fig, ax = plt.subplots(num_ax)
        else:
            # IMPORTANTE: CREO QUE ES MEJOR GRAFICAR COMO SI FUERAN DISTINTOS EJES
            # referenceTicks = ax.get_xticks()
            # kpoints, kTicks = fixKpath(referenceTicks, kpoints, kTicks)
            pass
        # ------ plot klabels and kticks ------
        for ktick in kticks:
            ax.axvline(ktick, color='gray', linewidth=0.2)
        ax.set_xticks(kticks)
        ax.set_xticklabels(klabels)

        ax.axhline(0, color='gray', linewidth=0.2)
        # -------------- plot bands --------------
        n = 0
        for band in E:
            band = band-E_zero
            if n==0 and label is not None:
                n+=1
                ax.plot(kpoints, band, c=color, linewidth=1.3, label=label)
            else:
                ax.plot(kpoints, band, c=color, linewidth=1.3)
        # ------------- set limits --------------
        ax.set_xlim([kticks[0], kticks[-1]])
        ax.set_ylim(E_limit)
        ax.set_ylabel(r'$E-E_{F} [eV]$')

        ax.format_coord = lambda x, y: 'x={:g}, y={:g}'.format(x, y) # To show coords.
        if show:
            plt.show()
        if savefile is not None:
            plt.savefig(savefile)

        return fig, ax

    def plot_path(self, x, y):
        # look script 'DFTandWannierPlotting.py'
        pass

    def plot_pathIntensity(self):
        # look script 'plot_curvature_bands.py'
        pass

    def plot_xy():
        # look script 'plot_curvature.py' or 'plot_AHC.py'
        pass

    def plot_grid():
        # For plotting Curvature on surface. 
        pass

    def _read_LDoS(self, path_read, fermi_vaspkit=False):
        '''
        Reads the local density of states generated by vaspkit1.3.5.
        '''        
        if os.path.isfile(path_read):
            data = np.loadtxt(path_read)
            data = data.transpose()
            # IMPORTANTE: Parece que el usar este metodo de sort no incrementa
            # tanto el tiempo, pero podriamos probar usando el sort de numpy.
            data = list(zip(*sorted(zip(*data))))
            data = np.array(data)
            E = data[0]
            orbitals = data[1:-1]
            total = data[-1]
            # 
            with open(path_read) as f:
                orbitals_labels = f.readline()
                orbitals_labels = orbitals_labels.split()[1:-1]
        else:
            print(f'File {path_read} not found.')
            exit()
        # ------- Adjust fermi level from FERMI_ENERGY file ----
        if fermi_vaspkit:
            path_Efermi = path_read + '/FERMI_ENERGY'
            Efermi = np.loadtxt(path_Efermi, skiprows=1)
            for i in range(len(E)):
                E[i] += Efermi
        
        
        return E, orbitals_labels, orbitals, total
    
    def plot_LDoS(self,
                  path_read,
                  roots=None,
                  orbitals_tag='all',
                  colors=['k'],
                  E_limit=None,
                  E_zero=0,
                  E_vaspkit=False,
                  ax=None,
                  show=False,
                  savefile=None):

        if ax is None:
            fig, ax = plt.subplots()
        else:
            fig, ax = ax
        # --------- read data ---------
        E, orbitals_labels, orbitals, total = self._read_LDoS(path_read+roots[0], E_vaspkit)
        ax.set_prop_cycle('color', colors)  # Colores a usar
        # ----- Sets zero energy level -----
        E -= E_zero
        # --------- plot partial DOS ---------
        if orbitals_tag=='all':
            for orbs, label in zip(orbitals, orbitals_labels):
                ax.plot(E, orbs, label=label)
        else:
            for tag in orbitals_tag:
                index = orbitals_labels.index(tag)
                ax.plot(E, orbitals[index], label=tag)
        # --------- plot total DOS ---------
        ax.plot(E, total, color='gray', linewidth=1, linestyle='--')

        ax.set_xlabel('Energy [eV]')
        ax.set_ylabel('Density of States (DOS)')
        if E_limit is not None:
            ax.set_xlim(E_limit)
        else:
            ax.set_xlim([min(E), max(E)])
        # if tag_bool and not DOS_total:
        #     ax.set_title('Right-click to hide all\nMiddle-click to show all',
        #             loc='right')  # , size='medium')
        #     ax.legend(loc='upper left', bbox_to_anchor=(1.05, 1),
        #             ncol=3)
        #     leg = interactive_legend()
        #     fig.subplots_adjust(right=0.55)
        
        if savefile is not None:
            plt.savefig(savefile)
        if show:
            plt.show()
        
        return fig, ax


class styler:
    '''
    Class to control style details of the graph.    
    '''
    def __init__(self, fig, ax):
        self.fig = fig
        self.ax = ax
        self.ax.format_coord = lambda x, y: 'x={:g}, y={:g}'.format(x, y) # To show coords.

    def set_style(self, style='default'):
        '''
        Set the style of the graph. It uses the matplotlib styles.
        '''
        plt.style.use(style)

    def set_size(self, figSize=[10, 8], figdpi=300):
        '''
        Set the dimensions of the graph.
        '''
        figWidht, figHeight = figSize
        self.fig.set_size_inches(figWidht, figHeight)
        self.fig.set_dpi(figdpi)
        self.fig.subplots_adjust()

    def set_title(self, maintitle=None, ax_title=None,
                    mtitle_fontsize=20, ax_title_fontsize=12):
        '''
        Set the titles of the graph.
        '''
        if maintitle:
            self.fig.suptitle(maintitle, fontsize=mtitle_fontsize)
        if ax_title:
            self.ax.set_title(ax_title, fontsize=ax_title_fontsize)

    def set_scale(self, scale_x='linear', scale_y='linear'):
        '''
        Set the scale used on each of the axes.
        '''
        self.ax.set_yscale(scale_x)
        self.ax.set_yscale(scale_y)

    def set_labels(self, xlabel=None, ylabel=None,
                    fontsize_xlabel=None, fontsize_ylabel=None):
        '''
        manage the labels of the graph.
        '''
        # ------------ Set the labels of the graph. ------------
        if xlabel:
            self.ax.set_xlabel(xlabel)
        if ylabel:
            self.ax.set_ylabel(ylabel)
        # ------------ Set the size of the text. ------------
        if fontsize_xlabel:
            self.ax.xaxis.label.set_fontsize(fontsize_xlabel)
        if fontsize_ylabel:
            self.ax.yaxis.label.set_fontsize(fontsize_ylabel)

    def set_ticks(self, xticks_step=None, yticks_step=None,
                  fontsize_xticks=None, fontsize_yticks=None):
        # ------------ Control step of the ticks. ------------
        if xticks_step:
            self.ax.xaxis.set_major_locator(ticker.MultipleLocator(xticks_step))
        if yticks_step:
            self.ax.yaxis.set_major_locator(ticker.MultipleLocator(yticks_step))
        # ------------ set fontsize of the ticks. ------------
        if fontsize_xticks:
            self.ax.tick_params(axis='x', labelsize=fontsize_xticks)
        if fontsize_yticks:
            self.ax.tick_params(axis='y', labelsize=fontsize_yticks)

    def set_lim(self, xlim=None, ylim=None):
        '''
        Set the limits of the graph.
        '''
        if xlim:
            self.ax.set_xlim(xlim)
        if ylim:
            self.ax.set_ylim(ylim)

    def set_frame_thickness(self, thickness=1):
        '''
        change te thickness of the frame of the graph.
        '''
        self.ax.spines['top'].set_linewidth(thickness)
        self.ax.spines['bottom'].set_linewidth(thickness)
        self.ax.spines['left'].set_linewidth(thickness)
        self.ax.spines['right'].set_linewidth(thickness)

    def return_fig_ax(self):
        return self.fig, self.ax

    def savefig(self, savefile, dpi=300, format='png'):
        '''
        Save the figure.
        '''
        self.fig.savefig(savefile+f'.{format}', dpi=dpi, format=format)


    def bandstructure_style(self, savefile=None):
        '''
        A default configuration for band structures figures.
        '''
        self.set_labels(ylabel=r'$E-E_{F} [eV]$', fontsize_ylabel=18)
        # self.set_scale()

        # self.ax.axhline(0, color='gray', linewidth=0.2)
        
        ylim = self.ax.get_ylim()
        self.set_ticks(yticks_step=min(abs(np.array(ylim)))/3, fontsize_yticks=14,
                        fontsize_xticks=14)

        self.set_size(figSize=[12, 8], figdpi=300)

        if savefile:
            self.savefig(savefile)

    def __interactive_legend(ax=None):
        if ax is None:
            ax = plt.gca()
        if ax.legend_ is None:
            ax.legend()
        return InteractiveLegend(ax.get_legend())


class InteractiveLegend(object):
    '''
    Class taken from:
    '''
    def __init__(self, legend):
        self.legend = legend
        self.fig = legend.axes.figure

        self.lookup_artist, self.lookup_handle = self._build_lookups(legend)
        self._setup_connections()

        self.update()

    def _setup_connections(self):
        for artist in self.legend.texts + self.legend.legendHandles:
            artist.set_picker(10) # 10 points tolerance

        self.fig.canvas.mpl_connect('pick_event', self.on_pick)
        self.fig.canvas.mpl_connect('button_press_event', self.on_click)

    def _build_lookups(self, legend):
        labels = [t.get_text() for t in legend.texts]
        handles = legend.legendHandles
        label2handle = dict(zip(labels, handles))
        handle2text = dict(zip(handles, legend.texts))

        lookup_artist = {}
        lookup_handle = {}
        for artist in legend.axes.get_children():
            if artist.get_label() in labels:
                handle = label2handle[artist.get_label()]
                lookup_handle[artist] = handle
                lookup_artist[handle] = artist
                lookup_artist[handle2text[handle]] = artist

        lookup_handle.update(zip(handles, handles))
        lookup_handle.update(zip(legend.texts, handles))

        return lookup_artist, lookup_handle

    def on_pick(self, event):
        handle = event.artist
        if handle in self.lookup_artist:

            artist = self.lookup_artist[handle]
            artist.set_visible(not artist.get_visible())
            self.update()

    def on_click(self, event):
        if event.button == 3:
            visible = False
        elif event.button == 2:
            visible = True
        else:
            return

        for artist in self.lookup_artist.values():
            artist.set_visible(visible)
        self.update()

    def update(self):
        for artist in self.lookup_artist.values():
            handle = self.lookup_handle[artist]
            if artist.get_visible():
                handle.set_visible(True)
            else:
                handle.set_visible(False)
        self.fig.canvas.draw()

    def show(self):
        plt.show()

'''
def legend_thickness(self, thickness=1):
    plt.rc('legend',fontsize=20) # using a size in points
    plt.rc('legend',fontsize='medium')
''' 